"""
TOTP MFA Provider Implementation

Time-based One-Time Password Multi-Factor Authentication provider.
"""

import base64
import io
import logging
from datetime import datetime, UTC
from typing import Any
from urllib.parse import quote

import pyotp
import qrcode
from qrcode.image.pure import PymagingImage

from app.modules.identity.domain.entities.admin.mfa_device import MFADevice, MFAMethod
from app.modules.identity.infrastructure.services.mfa_provider_factory import IMFAProvider

logger = logging.getLogger(__name__)


class TOTPMFAProvider(IMFAProvider):
    """TOTP-based MFA provider implementation."""
    
    def __init__(
        self,
        issuer: str = "EzzDay",
        algorithm: str = "SHA1",
        digits: int = 6,
        period: int = 30,
        window: int = 1
    ):
        """Initialize TOTP MFA provider.
        
        Args:
            issuer: Application name for authenticator apps
            algorithm: Hash algorithm (SHA1, SHA256, SHA512)
            digits: Number of digits in code
            period: Time period in seconds
            window: Time window for code acceptance
        """
        self.issuer = issuer
        self.algorithm = algorithm
        self.digits = digits
        self.period = period
        self.window = window
    
    @property
    def method(self) -> MFAMethod:
        """Get MFA method type."""
        return MFAMethod.TOTP
    
    @property
    def name(self) -> str:
        """Get provider name."""
        return "Time-based One-Time Password (TOTP)"
    
    async def send_code(
        self,
        device: MFADevice,
        user_identifier: str | None = None
    ) -> dict[str, Any]:
        """TOTP doesn't send codes - user generates them.
        
        Args:
            device: MFA device
            user_identifier: Optional user identifier
            
        Returns:
            Information about TOTP usage
        """
        if device.method != MFAMethod.TOTP:
            raise ValueError("Device must be TOTP method")
        
        # TOTP codes are generated by the user's authenticator app
        return {
            'sent': False,
            'message': 'Enter the code from your authenticator app',
            'digits': self.digits,
            'period': self.period
        }
    
    async def verify_code(
        self,
        device: MFADevice,
        code: str
    ) -> tuple[bool, dict[str, Any]]:
        """Verify TOTP code.
        
        Args:
            device: MFA device
            code: Verification code
            
        Returns:
            Tuple of (is_valid, metadata)
        """
        if device.method != MFAMethod.TOTP:
            return False, {'error': 'Device must be TOTP method'}
        
        if not device.secret or not device.secret.value:
            return False, {'error': 'Device has no secret configured'}
        
        # Create TOTP instance
        totp = pyotp.TOTP(
            device.secret.value,
            digits=self.digits,
            digest=self._get_hash_function(),
            interval=self.period,
            issuer=self.issuer
        )
        
        # Verify code with time window
        try:
            is_valid = totp.verify(code, valid_window=self.window)
            
            if is_valid:
                return True, {
                    'verified_at': datetime.now(UTC).isoformat(),
                    'method': 'totp',
                    'device_id': str(device.id)
                }
            else:
                return False, {'error': 'Invalid code'}
                
        except Exception as e:
            logger.error(f"TOTP verification error: {e}")
            return False, {'error': 'Verification failed'}
    
    async def setup_device(
        self,
        device: MFADevice,
        account_name: str | None = None
    ) -> dict[str, Any]:
        """Setup TOTP MFA device.
        
        Args:
            device: MFA device
            account_name: Optional account name for QR code
            
        Returns:
            Setup information including QR code
        """
        if device.method != MFAMethod.TOTP:
            raise ValueError("Device must be TOTP method")
        
        if not device.secret or not device.secret.value:
            raise ValueError("Device must have a secret")
        
        # Generate provisioning URI
        totp = pyotp.TOTP(
            device.secret.value,
            digits=self.digits,
            digest=self._get_hash_function(),
            interval=self.period,
            issuer=self.issuer
        )
        
        provisioning_uri = totp.provisioning_uri(
            name=account_name or str(device.user_id),
            issuer_name=self.issuer
        )
        
        # Generate QR code
        qr_code_data = self._generate_qr_code(provisioning_uri)
        
        return {
            'device_id': str(device.id),
            'secret': device.secret.value,
            'algorithm': self.algorithm,
            'digits': self.digits,
            'period': self.period,
            'qr_code': qr_code_data,
            'provisioning_uri': provisioning_uri,
            'manual_entry_key': self._format_secret_for_manual_entry(device.secret.value)
        }
    
    async def is_available(self) -> bool:
        """Check if provider is available."""
        # TOTP is always available as it doesn't require external services
        return True
    
    def _get_hash_function(self):
        """Get hash function for algorithm."""
        import hashlib
        
        hash_functions = {
            'SHA1': hashlib.sha1,
            'SHA256': hashlib.sha256,
            'SHA512': hashlib.sha512
        }
        
        return hash_functions.get(self.algorithm.upper(), hashlib.sha1)
    
    def _generate_qr_code(self, data: str) -> str:
        """Generate QR code as base64 data URL.
        
        Args:
            data: Data to encode in QR code
            
        Returns:
            Base64 encoded data URL
        """
        try:
            # Create QR code
            qr = qrcode.QRCode(
                version=1,
                error_correction=qrcode.constants.ERROR_CORRECT_L,
                box_size=10,
                border=4,
            )
            qr.add_data(data)
            qr.make(fit=True)
            
            # Create image
            img = qr.make_image(fill_color="black", back_color="white")
            
            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            buffer.seek(0)
            
            img_data = base64.b64encode(buffer.getvalue()).decode()
            return f"data:image/png;base64,{img_data}"
            
        except Exception as e:
            logger.error(f"Failed to generate QR code: {e}")
            # Return empty data URL on failure
            return "data:image/png;base64,"
    
    def _format_secret_for_manual_entry(self, secret: str) -> str:
        """Format secret for manual entry.
        
        Args:
            secret: TOTP secret
            
        Returns:
            Formatted secret with spaces
        """
        # Add spaces every 4 characters for readability
        return ' '.join([secret[i:i+4] for i in range(0, len(secret), 4)])
    
    def generate_current_code(self, secret: str) -> str:
        """Generate current TOTP code (for testing).
        
        Args:
            secret: TOTP secret
            
        Returns:
            Current code
        """
        totp = pyotp.TOTP(
            secret,
            digits=self.digits,
            digest=self._get_hash_function(),
            interval=self.period,
            issuer=self.issuer
        )
        
        return totp.now()
    
    def get_time_remaining(self) -> int:
        """Get seconds remaining in current time window.
        
        Returns:
            Seconds remaining
        """
        import time
        current_time = int(time.time())
        return self.period - (current_time % self.period)